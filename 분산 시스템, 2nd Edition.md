휴대전화 번호는 위치 독립적

분산 애플리케이션을 위한 실행 가능한 명명 시스템의 세 가지 초석
  일관된 명명 체계
  위치 독립성 
  확장 가능한 명명 서비스
  
이름은 트리 구조를 따르며, 부모는 그 아래의 서브 트리 이름의 공통 접미사입니다
 


RPC 구현

원격 프로시저를 호출하는 클라이언트는 서버에서 결과(또는 호출 완료를 알리는 메시지)를 받을 때까지 자신을 차단합니다

(1) 호출의 매개변수를 메시지로 패킹
(2) 메시지를 서버로 보냅
클라이언트가 자신을 차단

호출의 매개변수를 메시지로 패킹하는 작업을 매개변수 마샬링 이라고 합니다
네트워크 장애
RPC가 포함된 메시지가 서버로 가는 도중에 손실
클라이언트는 시간 초과 기간 후에 기다렸다가 RPC를 다시 시작하는 것 외에는 다른 대안이 거의 없습
어떤 이유로 첫 번째 RPC가 손실되지 않고 네트워크 어딘가에 갇힌 경우 RPC가 두 번 실행될 가능성
RPC가 원격 은행의 계좌에서 인출하고 작업이 두 번 이상 수행되면 불만이 생길 것입니다. 일부 애플리케이션에는 최소 한 번 의미론이 필요한 반면, 다른 애플리케이션에는 최대 한 번 의미론이나 정확히 한 번 의미론이 필요합니다.

원격 메서드 호출/RMI
 객체 지향 환경에서 RPC를 일반화한 것
 객체는 클라이언트의 머신과 다른 서버의 머신에 상주합니다
이를 원격 객체 라고 합니다
연관된 데이터 인스턴스가 여러 머신에 분산된 객체를 분산 객체 라고 합니다
. 클라이언트가 원격 객체에 대한 참조를 얻으면 마치 로컬에 있는 것처럼 이러한 원격 객체의 메서드를 호출할 수 있습니다
원격 객체 참조를 통해 객체에 적용된 모든 수정 사항은 서버에 반영되고 다른 클라이언트에서 사용할 수 있습니다
 클라이언트는 원격 객체가 포함된 서버의 위치를 ​​알 필요가 없습니다. 
프록시라는 인터페이스를 통해 메서드만 호출합니다
프록시는 호출 매개변수를 마샬링하고 서버에서 결과를 언마샬링하는 클라이언트 스텁입니다(

Java RMI는 로컬 및 원격 객체를 다르게 전달합니다. 모든 로컬 객체는 값으로 전달되는 반면 원격 객체는 참조로 전달됩니다. 값으로 호출하는 동안 객체의 상태는 명시적으로 복사되어 메서드 호출 본문에 포함됩니다. 참조로 호출 의 예는 다음과 같습니다. 각 프록시에는 (1) 원격 객체 X가 포함된 서버 S1의 네트워크 주소와 (2) 해당 서버에서 객체 X의 이름이 포함됩니다. 다른 서버 S2의 RMI의 일부로 클라이언트는 프록시(X에 대한 참조 포함)를 서버 S2에 전달합니다. 이제 S2는 S1에서 X에 액세스할 수 있습니다. 각 프로세스는 동일한 Java 가상 머신에서 실행되므로 하드웨어 플랫폼의 이질성에도 불구하고 매개변수의 언마샬링 이후에 추가 작업이 필요하지 않습니다.


메시지
대부분의 분산 애플리케이션은 메시지 전달을 사용하여 구현됩니다. 
메시징 계층은 논리적으로 TCP/IP 또는 UDP/IP 계층 바로 위에 있지만 애플리케이션 계층 아래에 ​​있습니다. 

일시적 메시지와 지속적 메시지

 일시적 통신 에서 메시지는 수신자가 메시지 전달 시점에 활성 상태이고 애플리케이션 수명 동안 검색하지 않는 한 손실됩니다
 
지속적 통신 에서 메시지는 손실되지 않지만 나중에 검색할 수 있도록 버퍼에 저장됩니다.예를 들어 이메일 통신이 있습니다


 
 스트림
한 사용자에게서 다른 사용자에게 비디오 클립을 보내는 것을 생각해 보세요
일반적으로 스트림은 데이터 항목의 시퀀스입니다.
시간적 관계 (초당 프레임 수 또는 전파 지연과 같은)를 기반으로 하며, 구현은 사용 가능한 네트워크 대역폭, 라우터의 버퍼 공간 및 최종 머신의 처리 속도에 따라 달라집니다.

웹 서비스

웹 서비스는 애플리케이션을 통합하는 데 도움이 되는 일종의 미들웨어입니다
오늘날 대부분의 웹 서비스는 크로스 플랫폼 데이터 통신에 널리 사용되는 XML을 기반으로 합니다. 여기에는 SOAP(Simple Object Access Protocol), WSDL(Web Service Description Language) 및 UDDI(Universal Description, Discovery, and Integration Specification) 및 Java 웹 서비스가 포함됩니다.

WSDL은 웹 서비스에 대한 퍼블릭 인터페이스

SOAP는 TCP, HTTP 또는 SMTP와 같은 전송 프로토콜을 사용하여 구조화된 데이터를 포함하는 단방향 메시지를 한 프로세스에서 다른 프로세스로 보낼 수 있도록 합니다. 
수신자가 발신자에게 답장을 보내면 메시지 교환이 완료됩니다
SOAP를 사용하여 서버 애플리케이션에서 RPC를 만드는 XML 기반 RPC 구현을 위한 Java API를 사용할 수 있습니다. RPC 호출을 SOAP 메시지에 매핑하는 표준 방식을 사용하면 인프라가 웹 서비스 플랫폼 주변의 코드를 재설계하지 않고도 런타임에 메서드 호출과 SOAP 메시지 간에 자동으로 변환할 수 있습니다.


이벤트 알림
이벤트 알림 시스템은 이기종 플랫폼에서 분산 객체 간에 비동기 통신 형태를 확립하는 데 도움이 되며 수많은 응용 프로그램이 있습니다.
게시-구독 통신의 특성
게시자나 구독자는 서로에 대해 아무것도 알 필요가 없지만 중개 계약을 통해 통신이 가능합니다
이벤트 알림 체계는 중앙 집중화된 환경에서의 인터럽트나 예외와 유사합니다
정의에 따르면 비동기적입니다.

다음은 몇 가지 다른 예입니다. 스마트 홈은 차고 문이 열려 있거나 수도꼭지가 흐르거나 정전이 발생할 때마다 집에 없는 소유자에게 전화를 걸 수 있습니다. 협업 작업 환경에서 프로세스는 모든 사람이 현재 작업 단계를 완료하면 다음 단계의 작업을 재개할 수 있습니다. 이는 이벤트로 알림을 받을 수 있습니다. 의료 시설의 중환자실에서 의사는 알림이 필요한 이벤트를 정의할 수 있습니다. 주식 보유자는 좋아하는 주식의 가격이 5% 이상 올라갈 때마다 알림을 받기를 원할 수 있습니다. 항공 승객은 환승 항공편 시간이 변경되면 스마트폰의 앱을 통해 알림을 받기를 원할 수 있습니다.

Apache River (원래 Sun Microsystems에서 개발한 Jini )는 Java 기반 플랫폼에 대한 이벤트 알림 서비스를 제공합니다. 이를 통해 한 Java 가상 머신(JVM)의 구독자가 다른 JVM에서 관심 있는 이벤트에 대한 알림을 받을 수 있습니다. 필수 구성 요소는 다음과 같습니다.

1. 사용자가 관심 있는 이벤트를 등록할 수 있는 이벤트 생성기 인터페이스 입니다 .
2. notify 메서드를 호출하여 구독자에게 알림을 제공하는 원격 이벤트 리스너 인터페이스 입니다. 각 알림은 원격 이벤트 클래스 의 인스턴스입니다 . notify 메서드 에 인수로 전달됩니다 .
3. 제3자 에이전트는 관찰자 역할을 하며 구독자 그룹에 유사한 이벤트를 전달하도록 조정하는 데 도움을 줍니다.

iPhone이나 iPad에서 실행되는 Apple의 iOS는 푸시 알림 서비스를 사용하여 짧은 문자 메시지나 사운드 바이트를 통해 사용자에게 이벤트 알림을 보냅니다

가상화: 클라우드 컴퓨팅

클라우드 컴퓨팅은 데이터 및/또는 프로그램이 사용자의 머신에 의해 저장되거나 관리되지 않고, 이를 서비스로 제공하는 제3자, 즉 클라우드 에 의해 관리되는 환경입니다 .

클라우드 컴퓨팅은 분산 컴퓨팅, 클러스터 컴퓨팅, 웹 서비스와 같은 여러 기술이 융합된 것입니다.
 모든 웹 애플리케이션은 이제 클라우드 컴퓨팅에 포함됩니다

맵리듀스
현대 분산 시스템의 중요한 특징 중 하나는 처리해야 할 방대한 양의 데이터입니다. 
 사진과 오디오 및 비디오 녹화가 지속적으로 생성되어 소셜 네트워크 사이트로 전달됩니다
신속한 응답을 생성하는 데 대량 병렬 데이터 처리 엔진이 필수적이 되었습니다.Google은 2004년에 MapReduce를 발명했고
Yahoo는 MapReduce 프로그램이 컴퓨팅 클러스터에서 실행될 수 있도록 하는 운영 체제인 오픈 소스 프로젝트 Hadoop 에 참여했습니다 .


기본 작업인 map 과 reduce 부터 시작해야 합니다
map 함수 는 목록의 모든 요소에 특정 함수를 적용실행은 병렬로 실행
각 프로세스 또는 스레드에는 이러한 작업 하나가 할당됩니다
 reduce 함수 는 map 작업의 출력을 가져와 최종 결과로 집계하는 집계 작업니다

MapReduce의 기본 데이터 구조는 < 키 , 값> 쌍입니다
x = 5이면 키 는 정수 변수 x 이고 값 은 5입니다
그래프의 경우 키는 노드의 식별자이고 값은 이웃 목록일 수 있습니다.

다음 텍스트에서 예제를 통해 MapReduce의 일반적인 응용 프로그램을 설명합니다.
디렉토리 D 에는 여러 개의 텍스트 파일
각각에는 텍스트가 포함

목표
이 두 파일에서 dog 라는 단어의 모든 발생과 cat 이라는 단어의 모든 발생을 캡처하여 계산 하고 각각에 대한 누적 결과를 생성

{단어 수 문제에 대한 의사 코드}
1: 매퍼 (디렉토리 D; 파일 f)
2: 파일 f의 모든 용어 "dog"에 대해
3: 출력("dog", 값 1)
1: 리듀서 (용어 "개"; 값 집합)
2: 총: = 0
3: 값 집합의 각 t에 대해
4: 총합: = 총합 + t
5: 출력(“dog”, total)

맵: 〈키 , 값〉→ 〈 키 , 값〉의 리스트
{이것은 중간의 〈key , value〉 쌍입니다}
Reduce: 〈키 , 값 목록 〉→ 〈 키 , 값〉목록












































































































































































































































































































































