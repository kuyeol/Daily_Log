## 장르 Redux

데이터베이스가 데이터를 저장하는 방식이 크게 관계형, 키-값, 컬럼형, 문서형, 그래프형의 5가지 장르로 나눌 수 있다는 것을 보셨을 겁니다. 잠시 시간을 내어 차이점을 요약하고 각 스타일이 어떤 데 좋고 어떤 데 좋지 않은지 살펴보겠습니다. 언제 사용해야 하고 언제 피해야 할지 알아보겠습니다.

# 관계형

이것은 가장 일반적인 클래식 데이터베이스 패턴입니다. 관계형 데이터베이스 관리 시스템(RDBMS)은 행과 열이 있는 2차원 테이블로 구현된 집합 이론 기반 시스템입니다. 관계형 데이터베이스는 유형을 엄격하게 적용하며 일반적으로 숫자, 문자열, 날짜 및 해석되지 않은 블롭이지만, 보셨듯이 PostgreSQL은 배열이나 큐브와 같은 확장을 제공합니다.

#### 좋은 점:

관계형 데이터베이스의 구조적 특성으로 인해 데이터 레이아웃은 미리 알 수 있지만 나중에 해당 데이터를 어떻게 사용할지 계획할 수 없는 경우에 적합합니다. 즉, 나중에 쿼리 유연성을 얻기 위해 조직의 복잡성을 미리 지불합니다. 주문에서 배송까지, 재고에서 쇼핑 카트까지 많은 비즈니스 문제가 이런 방식으로 적절하게 모델링됩니다. 나중에 데이터를 어떻게 쿼리할지 미리 알 수 없을 수도 있습니다. 2월에 몇 건의 주문을 처리했을까요? 하지만 데이터는 본질적으로 매우 규칙적이므로 이러한 규칙성을 적용하는 것이 도움이 됩니다.

#### 별로 좋지 않은 것:

데이터가 매우 가변적이거나 깊이 계층적일 때 관계형 데이터베이스는 가장 적합하지 않습니다. 스키마를 미리 지정해야 하기 때문에 레코드 간 변동이 심한 데이터 문제는 문제가 될 수 있습니다. 자연의 모든 생물을 설명하는 데이터베이스를 개발하는 것을 고려하세요. 설명할 모든 기능(hasHair, numLegs, laysEggs 등)의 전체 목록을 만드는 것은 어려울 것입니다. 그런 경우 미리 넣을 수 있는 것에 대한 제한이 적은 데이터베이스가 필요할 것입니다.

# 키-값

키-값(KV) 저장소는 우리가 다룬 가장 간단한 모델이었습니다. KV는 간단한 키를 매핑합니다. 때로는 문자열과 같은 간단한 값에 매핑하고, 때로는 거대한 해시 테이블과 같은 더 복잡한 값에 매핑합니다. 비교적 단순하기 때문에 이 데이터베이스 장르는 구현에 가장 큰 유연성이 있습니다. 해시 조회는 빠르므로 Redis의 경우 속도가 가장 중요한 관심사였습니다. 해시 조회는 또한 쉽게 분산되므로 DynamoDB는 파티셔닝 체계에서 이를 활용했습니다. 물론 단순성은 엄격하거나 복잡한 모델링 요구 사항이 있는 모든 데이터의 단점이 될 수 있습니다.

#### 좋은 점:

인덱스를 유지할 필요가 거의 없거나 전혀 없기 때문에 키-값 저장소는 종종 수평 확장성, 매우 빠른 속도 또는 둘 다로 설계됩니다. 이는 데이터가 크게 관련되지 않은 문제에 특히 적합합니다. 예를 들어, 웹 애플리케이션에서 사용자의 세션 데이터는 이 기준을 충족합니다. 각 사용자의 세션 활동은 다르고 다른 사용자의 활동과 크게 관련이 없습니다.

#### 별로 좋지 않은 것:

KV 저장소는 인덱스와 스캐닝 기능이 부족한 경우가 많으며, 기본 CRUD 작업(생성, 읽기, 업데이트, 삭제) 외에 데이터에 대한 쿼리를 수행해야 하는 경우에는 도움이 되지 않습니다.

# 컬럼형

열 기반 데이터베이스(일명 열 지향 또는 열 패밀리 )는 KV 및 RDBMS 저장소와 많은 유사점을 공유합니다. 키-값 데이터베이스와 마찬가지로 값은 일치하는 키로 쿼리됩니다. 관계형과 마찬가지로 값은 0개 이상의 열 그룹이지만 각 행은 원하는 만큼 채울 수 있습니다. 두 데이터베이스와 달리 열 기반 데이터베이스는 행별로 데이터를 함께 보관하는 대신 열별로 데이터를 저장합니다. 열을 추가하는 데 비용이 저렴하고 버전 관리가 간단하며 채워지지 않은 값에 대한 실제 저장 비용이 없습니다. HBase가 이 장르의 고전적인 구현인 것을 보았습니다.

#### 좋은 점:

컬럼형 데이터베이스는 전통적으로 수평적 확장성을 주요 설계 목표로 개발되었습니다. 따라서 수십, 수백 또는 수천 개의 노드 클러스터에서 작동하는 "빅 데이터" 문제에 특히 적합합니다. 또한 압축 및 버전 관리와 같은 기능에 대한 기본 제공 지원이 있는 경향이 있습니다. 좋은 컬럼형 데이터 저장 문제의 전형적인 예는 웹 페이지 인덱싱입니다. 웹의 페이지는 매우 텍스트적이며(즉, 압축의 이점을 얻을 수 있음) 다소 상호 연관되어 있으며 시간이 지남에 따라 변경됩니다(즉, 버전 관리의 이점을 얻을 수 있음).

#### 별로 좋지 않은 것:

다양한 컬럼형 데이터베이스는 기능이 다르므로 단점도 다릅니다. 하지만 공통점은 데이터를 쿼리할 방법에 따라 스키마를 설계하는 것이 가장 좋다는 것입니다. 즉, 데이터가 무엇으로 구성될지 뿐만 아니라 데이터가 어떻게 사용될지에 대한 아이디어가 미리 있어야 합니다. 데이터 사용 패턴을 미리 정의할 수 없는 경우(예: 빠른 임시 보고) 컬럼형 데이터베이스가 가장 적합하지 않을 수 있습니다.

# 문서

문서 데이터베이스는 객체당 아무리 많은 필드가 허용되고, 심지어 객체를 다른 필드의 값으로 아무리 깊이 중첩해도 허용합니다. 이러한 객체의 일반적인 표현은 MongoDB와 CouchDB가 모두 준수하는 JavaScript Object Notation(JSON)입니다. 그러나 이는 개념적 요구 사항은 아닙니다. 문서는 관계형 데이터베이스처럼 서로 관련이 없기 때문에 여러 서버에 샤딩하고 복제하기가 비교적 쉽기 때문에 분산 구현이 상당히 일반적입니다. MongoHQ는 웹의 거대한 데이터 세트를 관리하는 데이터 센터를 만드는 것을 지원하여 가용성을 해결하는 경향이 있습니다. 한편, CouchDB는 간단하고 내구성 있는 데 중점을 두고 있으며, 상당히 자율적인 노드의 마스터-마스터 복제를 통해 가용성을 달성합니다. 이러한 프로젝트 간에는 많은 중복이 있습니다.

#### 좋은 점:

문서 데이터베이스는 매우 가변적인 도메인과 관련된 문제에 적합합니다. 데이터가 정확히 어떻게 보일지 미리 알 수 없는 경우 문서 데이터베이스가 좋은 선택입니다. 또한 문서의 특성상 객체 지향 프로그래밍 모델에 잘 매핑되는 경우가 많습니다. 즉, 데이터베이스 모델과 애플리케이션 모델 간에 데이터를 이동할 때 임피던스 불일치가 적다는 의미입니다.

#### 별로 좋지 않은 것:

고도로 정규화된 관계형 데이터베이스 스키마에서 정교한 조인 쿼리를 수행하는 데 익숙하다면 문서 데이터베이스의 기능이 부족하다는 것을 알게 될 것입니다. 문서는 일반적으로 일반적인 사용에 필요한 대부분 또는 모든 관련 정보를 포함해야 합니다. 따라서 관계형 데이터베이스에서는 자연스럽게 데이터를 정규화하여 동기화되지 않을 수 있는 사본을 줄이거나 제거하지만 문서 데이터베이스에서는 비정규화된 데이터가 일반적입니다.

# 그래프

그래프 데이터베이스는 노드에 저장된 실제 값보다 데이터 노드 간의 상호 관계에 더 중점을 둔 새로운 종류의 데이터베이스입니다. 오픈 소스 사례인 Neo4j는 많은 소셜 네트워크 애플리케이션에서 인기를 얻고 있습니다. 유사한 객체의 컬렉션을 공통 버킷으로 그룹화하는 다른 데이터베이스 스타일과 달리 그래프 데이터베이스는 더 자유로운 형식입니다. 쿼리는 두 노드가 공유하는 에지를 따르거나 노드를 횡단하는 것으로 구성됩니다 . 더 많은 프로젝트에서 그래프 데이터베이스를 사용함에 따라 그래프 데이터베이스는 간단한 소셜 사례를 확대하여 추천 엔진, 액세스 제어 목록, 지리적 데이터와 같은 보다 미묘한 사용 사례를 차지합니다.

#### 좋은 점:

그래프 데이터베이스는 네트워킹 애플리케이션에 맞춤 제작된 것 같습니다. 전형적인 예는 소셜 네트워크로, 노드는 서로 다양한 종류의 관계를 가진 사용자를 나타냅니다. 다른 스타일을 사용하여 이런 종류의 데이터를 모델링하는 것은 종종 힘들지만 그래프 데이터베이스는 기꺼이 받아들일 것입니다. 또한 객체 지향 시스템에도 완벽하게 어울립니다. 화이트보드에서 데이터를 모델링할 수 있다면 그래프에서도 모델링할 수 있습니다.

#### 별로 좋지 않은 것:

노드 간의 높은 수준의 상호 연결성 때문에 그래프 데이터베이스는 일반적으로 네트워크 분할에 적합하지 않습니다. 그래프를 빠르게 스파이더링한다는 것은 다른 데이터베이스 노드로의 네트워크 홉을 감당할 수 없다는 것을 의미하므로 그래프 데이터베이스는 잘 확장되지 않습니다. 그래프 데이터베이스를 사용하는 경우 더 큰 시스템의 한 부분이 되어 대부분의 데이터는 다른 곳에 저장되고 관계만 그래프에서 유지될 가능성이 높습니다.




# 선택하기

처음에 말했듯이, 데이터는 석유와 같습니다. 우리는 방대한 데이터 바다 위에 앉아 있지만, 그것이 정보 로 정제되기 전까지 는 쓸모가 없습니다(그리고 좀 더 원시적인 비교를 하자면, 농담은 아니지만, 요즘은 데이터에 많은 돈이 들어갑니다). 데이터를 수집하고 궁극적으로 저장, 마이닝, 정제하는 것의 용이성은 여러분이 선택한 데이터베이스에서 시작됩니다.

어떤 데이터베이스를 선택할지 결정하는 것은 주어진 도메인의 데이터에 어떤 장르가 가장 잘 매핑되는지 고려하는 것보다 종종 더 복잡합니다. 소셜 그래프가 그래프 데이터베이스와 가장 잘 작동하는 것처럼 보일 수 있지만 Facebook이라면 하나를 선택할 수 없을 정도로 데이터가 너무 많습니다. HBase나 DynamoDB와 같은 "빅 데이터" 구현을 선택할 가능성이 더 큽니다. 이렇게 하면 열형 또는 키-값 저장소를 선택하게 됩니다. 다른 경우에는 관계형 데이터베이스가 은행 거래에 가장 적합한 옵션이라고 생각할 수 있지만 Neo4j도 ACID 거래를 지원하여 옵션을 확장한다는 사실을 아는 것이 좋습니다.

이러한 예는 문제 범위에 가장 적합한 데이터베이스(들)를 선택할 때 장르를 넘어 고려해야 할 다른 경로가 있다는 점을 지적합니다. 일반적으로 데이터 크기가 증가함에 따라 특정 데이터베이스 스타일의 용량은 줄어듭니다. 열 중심 데이터베이스 구현은 종종 데이터 센터 전체에 걸쳐 확장되고 가장 큰 "빅 데이터" 세트를 지원하도록 구축되는 반면 그래프는 일반적으로 가장 작은 세트를 지원합니다. 그러나 항상 그런 것은 아닙니다. DynamoDB는 사용자 관리가 필요 없이 수백 또는 수천 개의 노드에 데이터를 자동으로 분할하도록 설계된 대규모 키-값 저장소인 반면 Redis는 몇 개의 마스터-슬레이브 복제본 또는 클라이언트 관리 분할이 가능한 한 하나에서 실행되도록 구축되었습니다.

데이터베이스를 선택할 때 고려해야 할 몇 가지 차원이 더 있습니다. 예를 들어 내구성, 가용성, 일관성, 확장성, 보안 등이 있습니다. 임시 쿼리 가능성이 중요한지 아니면 mapreduce로 충분할지 결정해야 합니다. HTTP/REST 인터페이스를 사용하는 것을 선호하십니까? 아니면 사용자 지정 바이너리 프로토콜에 대한 드라이버가 필요합니까? 대량 데이터 로더의 존재와 같은 더 작은 범위 문제도 고려해야 할 수 있습니다.